# 进程

进程就是正在运行的程序。一个典型的系统可能看起来同时运行几十甚至几百个进程。这样做使系统易于使用，因为人们永远不需要关心 CPU 是否可用

## 尽管只有少数物理 CPU 可用，但操作系统如何提供几乎无穷无尽的所述 CPU 供应的错觉？

操作系统通过虚拟化 CPU 来制造这种错觉。通过运行一个进程，然后停止它并运行另一个进程，等等，操作系统可以促进许多虚拟 CPU 存在的错觉，而实际上只有一个（或几个）物理 CPU。这种被称为 CPU 时间共享的基本技术允许用户运行任意数量的并发进程；潜在的成本是性能，因为如果必须共享 CPU，每个进程都会运行得更慢

- CPU 时间共享？
时间共享是操作系统用来共享资源的一种基本技术。通过允许一个实体使用资源一会儿，然后另一个实体使用一会儿，依此类推，有问题的资源（例如 CPU 或网络链接）可以被许多人共享。时间共享的对应物是空间共享，资源在希望使用它的人之间进行分配（在空间中）。例如，磁盘空间自然是空间共享资源；一旦一个块被分配给一个文件，它通常不会被分配给另一个文件，直到用户删除原始文件

- 如何实现虚拟化？
操作系统将需要一些低级机器和一些高级智能。我们称之为低级机器机制；机制是实现所需功能的低级方法或协议。例如，我们稍后将学习如何实现上下文切换，它使操作系统能够停止运行一个程序并开始在给定的 CPU 上运行另一个程序；所有现代操作系统都采用这种分时机制

在这些机制之上，以策略的形式存在于操作系统中的一些智能。策略是用于在操作系统中做出某种决策的算法。例如，给定在 CPU 上运行的许多可能的程序，操作系统应该运行哪个程序？操作系统中的调度策略将做出这个决定，可能使用历史信息（例如，哪个程序在最后一分钟运行得更多？）、工作负载知识（例如，运行什么类型的程序）和性能指标（例如，系统是否针对交互式性能或吞吐量进行了优化？）来做出决定

## 抽象：进程

操作系统对正在运行的程序提供的抽象我们称之为进程

进程的组成：

- 进程可以寻址的内存（称为地址空间）是进程的一部分
- 寄存器对进程的执行很重要
- 程序计数器（PC）（有时称为指令指针或 IP）告诉我们接下来将执行程序的哪个指令；类似地，堆栈指针和相关帧指针用于管理函数参数、局部变量和返回地址的堆栈
- 程序也经常访问持久存储设备。此类 I/O 信息也是进程的一部分

## 进程 API

- 进程创建 API，创建一个进程来运行程序
- 进程终止 API，用来终止进程
- 进程等待 API，有时候让一个进程停止运行是有用的，比如你暂停游戏来去拿外卖
- 进程状态 API，获取进程的当前状态，运行了多长时间
- 进程控制 API，停止运行的进程一段时间后并恢复运行

- 程序如何转为进程？操作系统如何启动并运行程序？进程创建实际上是如何工作的？
将程序和静态数据加载到内存中的过程需要操作系统从磁盘读取这些字节并将它们放在内存中的某个地方

在早期（或简单）的操作系统中，加载过程是急切地完成的，即在运行程序之前一次完成；现代操作系统懒惰地执行该过程，即仅在程序执行期间根据需要加载代码或数据片段。要真正了解懒惰加载代码和数据片段的工作原理，您必须了解更多关于分页和交换机制，我们将在将来讨论内存虚拟化时讨论的主题。现在，请记住，在运行任何东西之前，操作系统显然必须做一些工作才能将重要的程序位从磁盘获取到内存中

一旦代码和静态数据被加载到内存中，在运行进程之前，操作系统还需要做一些其他的事情。必须为程序的运行时堆栈（或者只是堆栈）分配一些内存。正如您可能已经知道的，C 程序将堆栈用于局部变量、函数参数和返回地址；操作系统分配这些内存并将其提供给进程。操作系统也可能会使用参数初始化堆栈；具体来说，它会将参数填充到 main（）函数中，即 argc 和 argv 数组

操作系统也可以为程序的堆分配一些内存。在 C 程序中，堆用于显式请求的 dynamically-allocated 数据；程序通过调用 malloc（）来请求这些空间，并通过调用 free（）来显式释放它。链表、哈希表、树和其他有趣的数据结构等数据结构需要堆。首先，堆会很小；当程序运行并通过 malloc（）库 API 请求更多内存时，操作系统可能会参与进来，并为进程分配更多内存以帮助满足这些调用

操作系统还将执行一些其他初始化任务，特别是与输入 / 输出（I/O）相关的任务。例如，在 UNIX 系统中，每个进程默认有三个打开的文件描述符，用于标准输入、输出和错误；这些描述符让程序可以轻松地从终端读取输入并将输出打印到屏幕上。我们将在本书关于持久性的第三部分中了解更多关于 I/O、文件描述符等的信息

通过将代码和静态数据加载到内存中，通过创建和初始化堆栈，以及通过执行与 I/O 设置相关的其他工作，操作系统现在（终于）为程序执行设置了阶段。因此，它还有最后一个任务：在切入点启动程序运行，即 main（）。通过跳转到 main（）例程（通过我们将在下一章讨论的专门机制），操作系统将 CPU 的控制权转移到新创建的进程，从而程序开始执行

## 进程状态

- 运行状态
在运行状态下，一个进程正在处理器上运行。这意味着它正在执行指令

- 就绪状态
在就绪状态下，进程准备好运行，但由于某种原因，操作系统选择在当前不运行它

- 阻塞状态
在阻塞状态下，一个进程执行了某种操作，使其在其他事件发生之前无法运行。一个常见的例子：当一个进程向磁盘发起一个输入 / 输出请求时，它被阻塞，因此其他一些进程可以使用处理器

- 例子
如果我们将这些状态映射到一个图表上，我们将得到图 4.2 中的图表。正如您在图表中看到的，一个进程可以根据操作系统的判断在就绪和运行状态之间移动。从就绪状态移动到运行状态意味着进程已经被安排；从运行状态移动到就绪状态意味着进程已经被取消调度。一旦一个进程被阻塞（例如，通过启动 I/O 操作），操作系统将保持它的状态，直到某个事件发生（例如，I/O 完成）；此时，进程再次移动到就绪状态（如果操作系统决定，可能会立即再次运行）

让我们看一个例子，说明两个进程如何通过其中一些状态进行转换。首先，想象两个进程正在运行，每个进程都只使用 CPU（它们不使用 I/O）。在这种情况下，每个进程的状态跟踪可能如下所示

| 时间 | 进程 1 | 进程 2 |
| --- | --- | --- |
| 1 | 运行 | 就绪 |
| 2 | 运行 | 就绪 |
| 3 | 运行 | 就绪 |
| 4 | 运行 | 就绪 |
| 5 | - | 运行 |
| 6 | - | 运行 |
| 7 | - | 运行 |
| 8 | - | 运行 |

在下一个示例中，第一个进程在运行一段时间后发出 I/O。此时，该进程被阻塞，给另一个进程一个运行的机会

| 时间 | 进程 1 | 进程 2 |
| --- | --- | --- |
| 1 | 运行 | 就绪 |
| 2 | 运行 | 就绪 |
| 3 | 运行 | 就绪 |
| 4 | 阻塞 | 就绪 |
| 5 | 阻塞 | 运行 |
| 6 | 阻塞 | 运行 |
| 7 | 就绪 | 运行 |
| 8 | 就绪 | 运行 |
| 9 | 运行 | - |
| 10 | 运行 | - |

更具体地说，Process0 启动一个 I/O 并在等待它完成时被阻塞；例如，当从磁盘读取或等待来自网络的数据包时，进程会被阻塞。操作系统识别出 Process0 没有使用 CPU 并开始运行 Process1。当 Process1 运行时，I/O 完成，将 Process0 移回就绪状态。最后，Process1 完成，Process0 运行，然后完成

请注意，即使在这个简单的例子中，操作系统也必须做出许多决定。首先，系统必须决定在 Process0 发出 I/O 时运行 Process1；这样做可以通过保持 CPU 忙碌来提高资源利用率。其次，系统决定在其 I/O 完成时不切换回 Process0；尚不清楚这是否是一个好的决定。你怎么看？这些类型的决定是由操作系统调度程序做出的，我们将在未来的几章中讨论这个主题

## 数据结构

操作系统是一个程序，像任何程序一样，它有一些关键的数据结构来跟踪各种相关的信息。例如，为了跟踪每个进程的状态，操作系统可能会为所有准备好的进程保留某种进程列表，并保留一些附加信息来跟踪当前正在运行的进程。操作系统还必须以某种方式跟踪阻塞的进程；当输入输出事件完成时，操作系统应该确保唤醒正确的进程并准备好再次运行

操作系统需要跟踪 xv6 内核 [CK+08] 中每个进程的信息类型。类似的进程结构存在于 “真正的” 操作系统中，如 Linux、苹果 OS X 或视窗；查找它们，看看它们有多复杂。
从图中，您可以看到操作系统跟踪进程的一些重要信息

```cpp
struct context {
    uint64 eip;  // 指令指针寄存器（指向下一条要执行的指令）
    uint64 esp;  // 栈指针寄存器（指向当前栈顶）
    uint64 ebx;  // 基址寄存器（通用寄存器）
    uint64 ecx;  // 计数寄存器（通用寄存器）
    uint64 edx;  // 数据寄存器（通用寄存器）
    uint64 esi;  // 源索引寄存器（通用寄存器）
    uint64 edi;  // 目的索引寄存器（通用寄存器）
    uint64 ebp;  // 基址指针寄存器（指向当前栈帧的基址）
};

struct process {
    char* mem;               // 进程的内存空间（指向进程的虚拟内存）
    uint64 size;             // 进程的内存大小
    char* kstack;            // 进程的内核栈（用于内核态执行时保存栈信息）

    enum process_state state; // 进程的当前状态（如运行、就绪、阻塞等）
    uint64 pid;              // 进程的唯一标识符（进程ID）
    struct process* parent;  // 指向父进程的指针（用于进程树结构）
    void* chan;              // 进程的等待通道（用于进程间通信或同步）
    int killed;              // 进程是否被杀死（非 0 表示被杀死）

    struct file* ofile[NOFILE]; // 进程打开的文件列表（文件描述符表）
    struct inode* cwd;       // 进程的当前工作目录（指向文件系统的 inode）
    struct context context;  // 进程的 CPU 上下文（用于上下文切换）
    struct trapframe* tf;    // 进程的陷阱帧（用于保存中断或异常时的 CPU 状态）
};
```

停止的进程，其寄存器的内容。当一个进程停止时，它的寄存器将保存到这个内存位置；通过恢复这些寄存器（即将它们的值放回实际的物理寄存器），操作系统可以恢复运行该进程。我们将在以后的章节中详细了解这种称为上下文切换的技术。
您还可以从图中看到，除了运行、就绪和阻塞之外，进程还可以处于其他一些状态。有时，系统会有一个初始状态，即进程在创建时所处的状态。此外，一个进程可以被置于它已经退出的最终状态，但是尚未被清理（在基于 UNIX 的系统中，这称为僵尸状态 1）。这个最终状态可能很有用，因为它允许其他进程（通常是创建进程的父进程）检查进程的返回代码，看看刚刚完成的进程是否成功执行（通常，程序在基于 UNIX 的系统中成功完成任务时返回零，否则返回非零）。完成后，父进程将进行最后一次调用（例如 wait（））以等待子进程完成，并向操作系统指示它可以清理引用现已灭绝进程的任何相关数据结构

## 总结

我们已经介绍了操作系统最基本的抽象：进程。它被简单地视为一个正在运行的程序。考虑到这一概念观点，我们现在将进入本质：实现进程所需的低级机制，以及以智能方式调度它们所需的高级策略。通过结合机制和策略，我们将建立对操作系统如何虚拟化 CPU 的理解

## 进程 API

fork() 系统调用用于创建一个新进程，创建的进程是调用进程的（几乎）精确副本，新创建的进程（称为子进程，与创建父进程相反）不会像您所期望的那样在 main（）开始运行（注意，“hello” 消息只打印了一次）；相反，它就像调用 fork（）本身一样出现了

wait() 系统调用用于等待子进程完成，父进程等待子进程完成它一直在做的事情是非常有用的。这项任务是通过 wait() 系统调用（或其更完整的兄弟 waitpid() ）完成的

exec() 系统调用用于在当前进程中运行新程序
exit() 系统调用用于终止当前进程
kill（）系统调用用于向进程发送信号，包括暂停、死亡和其他有用命令的指令
